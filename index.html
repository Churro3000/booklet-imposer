<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Booklet Imposer — A4 → A6 (Auto Flip Backs)</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; background:#f7f7f8; padding:18px; color:#111 }
    .container{max-width:980px;margin:0 auto;background:#fff;padding:18px;border-radius:8px;box-shadow:0 6px 22px rgba(0,0,0,.06)}
    h1{margin:0 0 10px;font-size:20px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px}
    input[type=file]{display:block}
    button{background:#0069ff;color:#fff;padding:8px 12px;border-radius:6px;border:0;cursor:pointer}
    .small{font-size:13px;color:#555}
    pre{background:#f4f4f6;padding:10px;border-radius:6px;overflow:auto}
  </style>
</head>
<body>
  <div class="container">
    <h1>Booklet Imposer — A4 → A6 (16pp / A4 sheet)</h1>
    <p class="small">Upload image files named by page number (e.g. <code>1.png</code>, <code>2.jpg</code>). The tool will sort them and impose into A4 sheets (8 A6 slots). Every second side is flipped for double-sided printing. Click <strong>Generate PDF</strong> when ready.</p>

    <div class="controls">
      <input id="fileInput" type="file" accept="image/*,image/png,image/jpeg" multiple />
      <button id="generateBtn">Generate PDF</button>
      <button id="clearBtn" style="background:#999">Clear</button>
    </div>

    <div id="status" class="small">No files loaded</div>

    <details style="margin-top:12px"><summary>Imposition pattern used (one signature of 16 pages)</summary>
      <pre id="pattern" class="small"></pre>
    </details>

    <p class="small" style="margin-top:12px">Note: This runs fully in your browser. For higher DPI or exact bleed alignment, tweak the <code>dpi</code> value in the code.</p>
  </div>

  <!-- React + Babel + jsPDF -->
  <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/babel-standalone@6/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <script type="text/babel">
  const frontOrder = [16,12,1,5,14,10,3,7];
  const backOrder  = [15,11,2,6,13,9,4,8];
  document.getElementById('pattern').textContent = 'Front: ' + frontOrder.join(', ') + '\\nBack:  ' + backOrder.join(', ');

  function loadImageFromFile(file){
    return new Promise((res, rej) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => { URL.revokeObjectURL(url); res(img); };
      img.onerror = (e) => { URL.revokeObjectURL(url); rej(e); };
      img.src = url;
    });
  }

  function App(){
    const [files, setFiles] = React.useState([]);
    const fileInput = React.useRef();

    function msg(s){ document.getElementById('status').textContent = s; }

    async function handleFiles(e){
      const fl = Array.from(e.target.files || []);
      const imgs = fl.filter(f => /image\\/(png|jpe?g)/.test(f.type));
      const parsed = imgs.map(f => {
        const base = f.name.replace(/\\.[^/.]+$/,'');
        const m = base.match(/(\\d+)/);
        const n = m ? parseInt(m[1],10) : null;
        return { file: f, index: n, name: f.name };
      }).sort((a,b)=>{
        if(a.index==null && b.index==null) return a.name.localeCompare(b.name);
        if(a.index==null) return 1;
        if(b.index==null) return -1;
        return a.index - b.index;
      });
      setFiles(parsed);
      msg(parsed.length + ' image(s) loaded');
    }

    function clearAll(){
      setFiles([]);
      fileInput.current.value = null;
      msg('Cleared');
    }

    async function generate(){
      if(!files.length){ msg('No files'); return; }
      msg('Loading images...');
      const pages = [];
      for(const p of files){
        try{
          const img = await loadImageFromFile(p.file);
          pages.push({img, index: p.index});
        }catch(e){ console.warn('load fail', e); }
      }
      pages.sort((a,b)=>a.index-b.index);
      const pageMap = [];
      let maxPage = 0;
      for(const p of pages){
        pageMap[p.index] = p.img;
        maxPage = Math.max(maxPage,p.index);
      }

      const totalPages = maxPage;
      const pagesPerSheet = 16;
      const numSheets = Math.ceil(totalPages / pagesPerSheet);
      msg('Rendering ' + numSheets + ' sheet(s)...');

      const a4mm = { w:210, h:297 };
      const dpi = 150, pxPerMm = dpi/25.4;
      const a4px = { w: Math.round(a4mm.w * pxPerMm), h: Math.round(a4mm.h * pxPerMm) };
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({ unit:'mm', format:'a4' });

      async function drawSide(imgArray, flip){
        const canvas = document.createElement('canvas');
        canvas.width = a4px.w; canvas.height = a4px.h;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle='#fff'; ctx.fillRect(0,0,canvas.width,canvas.height);
        const marginPx = Math.round(5*pxPerMm);
        const cols=2, rows=4;
        const usableW = canvas.width - marginPx*2;
        const usableH = canvas.height - marginPx*2;
        const cellW = usableW / cols;
        const cellH = usableH / rows;

        ctx.save();
        if(flip){
          // Flip horizontally + vertically
          ctx.translate(canvas.width, canvas.height);
          ctx.rotate(Math.PI);
        }

        for(let i=0;i<8;i++){
          const img = imgArray[i];
          const col = i%cols, row=Math.floor(i/cols);
          const x = marginPx + col*cellW;
          const y = marginPx + row*cellH;
          if(img){
            const padW=cellW*0.94, padH=cellH*0.94;
            const scale=Math.min(padW/img.width, padH/img.height);
            const dw=img.width*scale, dh=img.height*scale;
            const dx=x+(cellW-dw)/2, dy=y+(cellH-dh)/2;
            ctx.drawImage(img,dx,dy,dw,dh);
          }
        }
        ctx.restore();
        const dataURL=canvas.toDataURL('image/jpeg',0.9);
        pdf.addImage(dataURL,'JPEG',0,0,a4mm.w,a4mm.h);
        pdf.addPage();
      }

      for(let s=0;s<numSheets;s++){
        const base = s*pagesPerSheet;
        const frontImgs = frontOrder.map(k=>pageMap[base+k]||null);
        const backImgs  = backOrder.map(k=>pageMap[base+k]||null);

        await drawSide(frontImgs,false);     // normal front
        await drawSide(backImgs,true);       // flipped back
        msg('Rendered sheet ' + (s+1) + ' of ' + numSheets);
      }

      pdf.deletePage(pdf.getNumberOfPages());
      pdf.save('booklet-flipped.pdf');
      msg('Done — download started');
    }

    React.useEffect(()=>{
      document.getElementById('fileInput').addEventListener('change',handleFiles);
      document.getElementById('generateBtn').onclick=generate;
      document.getElementById('clearBtn').onclick=clearAll;
      return ()=>{};
    },[]);

    return React.createElement('div', null);
  }

  ReactDOM.render(React.createElement(App), document.body.appendChild(document.createElement('div')));
  </script>
</body>
</html>
