<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Booklet Imposer — A4 → A6 (16pp / sheet)</title>
  <style>
    body {font-family:system-ui,-apple-system,"Segoe UI",Roboto,sans-serif;background:#f7f7f8;padding:18px;color:#111}
    .container{max-width:980px;margin:0 auto;background:#fff;padding:18px;border-radius:8px;box-shadow:0 6px 22px rgba(0,0,0,.06)}
    h1{margin:0 0 10px;font-size:20px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px}
    button{background:#0069ff;color:#fff;padding:8px 12px;border-radius:6px;border:0;cursor:pointer}
    button:disabled{background:#aaa;cursor:not-allowed}
    .small{font-size:13px;color:#555}
    pre{background:#f4f4f6;padding:10px;border-radius:6px;overflow:auto}
  </style>
</head>
<body>
  <div class="container">
    <h1>Booklet Imposer — A4 → A6 (16pp / sheet)</h1>
    <p class="small">
      Upload images named by page number (<code>1.png</code>, <code>2.jpg</code> …).
      The tool will sort them, impose 8 A6 cells per A4 side, and flip every back-side for duplex printing.
    </p>
    <div class="controls">
      <input id="fileInput" type="file" accept="image/*" multiple />
      <button id="generateBtn">Generate PDF</button>
      <button id="clearBtn" style="background:#999">Clear</button>
    </div>
    <div id="status" class="small">No files loaded</div>
    <details style="margin-top:12px">
      <summary>Imposition pattern (one 16-page signature)</summary>
      <pre id="pattern" class="small"></pre>
    </details>
  </div>

  <!-- React + Babel + jsPDF -->
  <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/babel-standalone@6/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <script type="text/babel">
    // ----- imposition order for ONE 16-page signature -----
    const frontOrder = [16,12,1,5,14,10,3,7];
    const backOrder  = [15,11,2,6,13,9,4,8];
    document.getElementById('pattern').textContent =
      'Front: ' + frontOrder.join(', ') + '\nBack : ' + backOrder.join(', ');

    const PAGES_PER_SHEET = 16;
    const CELLS_PER_SIDE  = 8;               // 2 cols × 4 rows
    const DPI = 150;
    const PX_PER_MM = DPI / 25.4;
    const A4_MM = {w:210, h:297};
    const A4_PX = {
      w: Math.round(A4_MM.w * PX_PER_MM),
      h: Math.round(A4_MM.h * PX_PER_MM)
    };
    const MARGIN_MM = 5;
    const MARGIN_PX = Math.round(MARGIN_MM * PX_PER_MM);

    // ---- helper: load image from File object ----
    const loadImage = file => new Promise((res, rej) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => { URL.revokeObjectURL(url); res(img); };
      img.onerror = e => { URL.revokeObjectURL(url); rej(e); };
      img.src = url;
    });

    // ---- React app -------------------------------------------------
    function App() {
      const [pageFiles, setPageFiles] = React.useState([]); // [{idx, file}]
      const fileInputRef = React.useRef();
      const setStatus = txt => document.getElementById('status').textContent = txt;

      // ---- file selection ------------------------------------------------
      const onFiles = e => {
        const files = Array.from(e.target.files || []);
        const imgs = files.filter(f => /^image\//.test(f.type));

        const parsed = imgs.map(f => {
          const name = f.name.replace(/\.[^.]+$/,'');      // strip extension
          const m = name.match(/(\d+)/);
          const idx = m ? parseInt(m[1],10) : null;
          return {idx, file: f};
        }).filter(p => p.idx !== null)                 // keep only numbered files
          .sort((a,b) => a.idx - b.idx);

        setPageFiles(parsed);
        setStatus(`${parsed.length} page(s) loaded`);
      };

      const clear = () => {
        setPageFiles([]);
        if (fileInputRef.current) fileInputRef.current.value = null;
        setStatus('Cleared');
      };

      // ---- PDF generation ------------------------------------------------
      const generate = async () => {
        if (!pageFiles.length) { setStatus('No pages'); return; }

        // ---- 1. load every uploaded image into a map (idx → Image) ----
        setStatus('Loading images…');
        const imgMap = {};               // idx → HTMLImageElement
        for (const {idx, file} of pageFiles) {
          try { imgMap[idx] = await loadImage(file); }
          catch (e) { console.warn('load failed', idx, e); }
        }

        // ---- 2. find the highest page number that exists ----
        const uploadedIndices = Object.keys(imgMap).map(Number);
        const maxUploaded = uploadedIndices.length ? Math.max(...uploadedIndices) : 0;
        if (maxUploaded === 0) { setStatus('No valid pages'); return; }

        // ---- 3. pad to a multiple of 16 (blank pages) ----
        const totalPages = Math.ceil(maxUploaded / PAGES_PER_SHEET) * PAGES_PER_SHEET;
        const numSheets  = totalPages / PAGES_PER_SHEET;

        // ---- 4. build a dense array: pages[0] = image for page 1, pages[1] = page 2, … (null = blank) ----
        const pages = new Array(totalPages).fill(null);
        for (const idx of uploadedIndices) {
          pages[idx - 1] = imgMap[idx];
        }

        setStatus(`Rendering ${numSheets} sheet(s) (${totalPages} pages total)…`);

        const {jsPDF} = window.jspdf;
        const pdf = new jsPDF({unit:'mm', format:'a4'});

        // ---- reusable drawer ------------------------------------------------
        const drawSide = async (orderArray, doFlip) => {
          const canvas = document.createElement('canvas');
          canvas.width  = A4_PX.w;
          canvas.height = A4_PX.h;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#fff';
          ctx.fillRect(0,0,canvas.width,canvas.height);

          if (doFlip) {
            ctx.translate(canvas.width, canvas.height);
            ctx.rotate(Math.PI);
          }

          const usableW = canvas.width  - 2*MARGIN_PX;
          const usableH = canvas.height - 2*MARGIN_PX;
          const cellW = usableW / 2;
          const cellH = usableH / 4;

          for (let i=0; i<CELLS_PER_SIDE; i++) {
            const pageNum = orderArray[i];            // 1-based
            const img = (pageNum <= totalPages) ? pages[pageNum-1] : null;

            const col = i % 2;
            const row = Math.floor(i / 2);
            const x = MARGIN_PX + col * cellW;
            const y = MARGIN_PX + row * cellH;

            if (img) {
              const pad = 0.94;
              const scale = Math.min((cellW*pad)/img.width, (cellH*pad)/img.height);
              const dw = img.width * scale;
              const dh = img.height * scale;
              const dx = x + (cellW - dw)/2;
              const dy = y + (cellH - dh)/2;
              ctx.drawImage(img, dx, dy, dw, dh);
            }
          }

          const dataURL = canvas.toDataURL('image/jpeg', 0.92);
          pdf.addImage(dataURL, 'JPEG', 0, 0, A4_MM.w, A4_MM.h);
          pdf.addPage();
        };

        // ---- build each sheet (front + back) ----
        for (let s=0; s<numSheets; s++) {
          const base = s * PAGES_PER_SHEET + 1;   // first page of this signature

          const front = frontOrder.map(off => base + off - 1);
          const back  = backOrder .map(off => base + off - 1);

          await drawSide(front, false);   // front – normal
          await drawSide(back , true );   // back  – 180° flip

          setStatus(`Sheet ${s+1}/${numSheets} rendered`);
        }

        // remove the extra empty page that jsPDF adds after the last addPage()
        pdf.deletePage(pdf.getNumberOfPages());
        pdf.save('booklet.pdf');
        setStatus('Download started');
      };

      // ---- wiring ------------------------------------------------
      React.useEffect(() => {
        const fi  = document.getElementById('fileInput');
        const gen = document.getElementById('generateBtn');
        const clr = document.getElementById('clearBtn');

        fileInputRef.current = fi;
        fi.addEventListener('change', onFiles);
        gen.onclick = generate;
        clr.onclick = clear;

        return () => {
          fi.removeEventListener('change', onFiles);
          gen.onclick = null;
          clr.onclick = null;
        };
      }, []);

      return null;   // UI lives in the static HTML above
    }

    // render the tiny React app (only for state)
    ReactDOM.render(React.createElement(App), document.body.appendChild(document.createElement('div')));
  </script>
</body>
</html>
